package analizadores;


import ast.ArbolAST;
import ast.NodoAST;
import ast.entorno.Simbolo;
import ast.expresiones.*;
import ast.expresiones.operacion.*;
import ast.expresiones.primitivos.*;
import ast.instrucciones.declaraciones.*;
import ast.instrucciones.*;
import ast.instrucciones.Printer;
import ast.instrucciones.Seleccion.*;
import ast.instrucciones.ciclos.*;
import ast.instrucciones.ciclos.RetCont.*;
import java.util.LinkedList;
import java_cup.runtime.*;


parser code

{:
    public Instruccion arbol;
    public void syntax_error(Symbol s){
        System.err.println(s);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.err.println("Error caracter no esperado");
        System.err.println(s);
    }
:}


action code
{://Codigo de acciones
      
:}


terminal String igual, allave, cllave, id, puntoycoma, acorchete, ccorchete, neww;
terminal String intt, charr, stringg, doublee, booleann; //TIpo dato
terminal String cadena, truee, falsee,charER;
terminal Object entero, decimal; //tipos primitivos
terminal String imprimir, apar, cpar; 
terminal String mas, por, menos, dividir, potencia; //aritmeticas
terminal String oor, aand, diferenteunario; //logica
terminal String igualigual, mayorq, menorq, menorigualq, mayorigualq, diferente;
terminal String interrogacion, dospuntos, whilee, breakk, continuee, masmas, menosmenos, masmaspost, menosmenospost; //ternario
terminal String iff, elsee, doo, forr, switchh, casee, defaultt;
terminal String MENOSUNARIO, MASUNARIO;
terminal String write_file, read_file, coma, grafica;
terminal String publico, protegido, privado, estatico, finall;

terminal String print, printLinea;

nonterminal I;
nonterminal Instruccion S;
nonterminal LinkedList<NodoAST> B;
nonterminal Expresion E;
//nonterminal Instruccion D;
nonterminal TipoContenedor T;
nonterminal NodoAST J;
nonterminal Instruccion CICLOS;
nonterminal Instruccion COND;
nonterminal Instruccion IF_STATEMENT;
nonterminal LinkedList<IfLista> IF_LIST;
nonterminal Instruccion FOR_INIT;
nonterminal Instruccion IMPRESIONES;
nonterminal Expresion PREPOSTFIJOS;
nonterminal Instruccion SWITCH_BLOCK;
nonterminal LinkedList<NodoAST> SWITCH_BLOCK_STATEMENT_GROUPS;
nonterminal LinkedList<NodoAST> SWITCH_LABELS;
nonterminal NodoAST SWITCH_LABEL;
nonterminal Instruccion SWITCH_BLOCK_STATEMENT_GROUP;
nonterminal NodoAST ARCHIVOS;
nonterminal PARACORCHETE;

nonterminal LinkedList<NodoAST> VARIABLE_DECLARATOR_ID;
nonterminal Object VARIABLE_DECLARATOR;
nonterminal LinkedList<Object> VARIABLE_DECLARATORS;
nonterminal String FIELD_MODIFIER;
nonterminal LinkedList<String> FIELD_MODIFIERS;
nonterminal Instruccion FIELD_DECLARATION;


//precedence left id;
precedence left interrogacion;
precedence left oor;
precedence left aand;
precedence right diferenteunario; //not
precedence left igualigual, diferente;
precedence left mayorq, menorq, menorigualq, mayorigualq;
precedence left mas, menos;
precedence left por, dividir;
precedence left potencia;
precedence right masmas, menosmenos;
precedence left masmaspost, menosmenospost;
precedence right MENOSUNARIO, MASUNARIO;



start with I;

I::= S:l{:
        this.parser.arbol = l;
    :};

//"S" es el bloque
S::= allave B:l cllave {:
        RESULT = new Bloque(l);
    :};
    
B::= B:l J:i {:
        RESULT = l;
        RESULT.add(i);
    :}
    |J:i {:
        RESULT = new LinkedList<>();
        RESULT.add(i);
    :};

J::= /*D:d {:
        RESULT = d;
    :}*/
    FIELD_DECLARATION:d{:
        RESULT = d;
    :}
    |S:d {:
        RESULT = d;
    :}
    |CICLOS:d {:
        RESULT = d;
    :}
    |COND:d{:
        RESULT = d;
    :}
    |IMPRESIONES:d {:
        RESULT = d;
    :}
    |PREPOSTFIJOS:d {:
        RESULT = d;
    :}
    |ARCHIVOS:d{:
        RESULT = d;
    :};



ARCHIVOS::=  read_file apar E:ruta cpar puntoycoma {:
                RESULT = new LeerArchivo(ruta, rutaleft, rutaright);
            :}
            |write_file:a apar E:ruta coma E:contenido cpar puntoycoma{:
                RESULT = new EscribirArchivo(ruta, contenido, aleft, aright);
            :}
            |grafica apar E:ruta coma E:contenido cpar puntoycoma{:
                RESULT = new Graficar(ruta, contenido, rutaleft, rutaright);
            :};          




COND::= IF_STATEMENT:d {:
        RESULT = d;
      :}
      |SWITCH_BLOCK:d {:
        RESULT = d;
      :};


SWITCH_BLOCK::= switchh apar E:e cpar allave SWITCH_BLOCK_STATEMENT_GROUPS:g SWITCH_LABELS:s cllave {:
                    RESULT = new SwitchBlock(e, eleft, eright, g, s);
                :}
                |switchh apar E:e cpar allave SWITCH_BLOCK_STATEMENT_GROUPS:grupo cllave {:
                    RESULT = new SwitchBlock(e, eleft, eright, grupo, null);
                :}
                |switchh apar E:e cpar allave SWITCH_LABELS:swi cllave {:
                    RESULT = new SwitchBlock(e, eleft, eright, null, swi);
                :}
                |switchh apar E:e cpar allave cllave {:
                    //no se hace nada
                :};


SWITCH_BLOCK_STATEMENT_GROUPS::= SWITCH_BLOCK_STATEMENT_GROUP:i {:
                    RESULT = new LinkedList<>();
                    RESULT.add(i);
                :}
                |SWITCH_BLOCK_STATEMENT_GROUPS:f SWITCH_BLOCK_STATEMENT_GROUP:dnodo{:
                    RESULT = f;
                    RESULT.add(dnodo);
                :};


SWITCH_BLOCK_STATEMENT_GROUP::= SWITCH_LABELS:listaCase B:listaSentencias {: //cambiar la S por una B y toca instanciar una clase Bloque para mandar a guardar
                    Bloque blo = new Bloque(listaSentencias);
                    RESULT = new SwitchBlockStatement_Group(listaCase, blo);
                :};

SWITCH_LABELS::= SWITCH_LABEL:i {:
                    RESULT = new LinkedList<>();
                    RESULT.add(i);
                :}
                |SWITCH_LABELS:f SWITCH_LABEL:dnodo{:
                    RESULT = f;
                    RESULT.add(dnodo);
                :};

SWITCH_LABEL::= casee E:e dospuntos {:
                    RESULT = new Casee(e, eleft, eright);
                :}
                |defaultt:d dospuntos{:
                    RESULT = new Defaultt(dleft, dright);
                :};



IF_STATEMENT::= IF_LIST:i elsee S:s1{:
            RESULT = new Iff(s1, i, ileft, iright);
        :}
        |IF_LIST:i {:
            RESULT = new Iff(null, i, ileft, iright);
        :};

IF_LIST::= iff apar E:e1 cpar S:s1 {:
            RESULT = new LinkedList<IfLista>();
            RESULT.add(new IfLista(e1, s1, e1left, e1right));
        :}
        |IF_LIST:l elsee iff apar E:e1 cpar S:s1{:
            RESULT = l;
            RESULT.add(new IfLista(e1, s1, e1left, e1right));
        :};


CICLOS::= whilee apar E:e1 cpar S:s1 {:
        RESULT = new WhileCiclo(e1, s1, e1left, e1right);
    :}
    |breakk:e puntoycoma{:
        RESULT = new Breakk(eleft, eright);
    :}
    |continuee:e puntoycoma {:
        RESULT = new Continuee(eleft, eright);
    :}
    |doo:d S:s1 whilee apar E:e1 cpar puntoycoma{:
        RESULT = new DoWhile(s1, e1, dleft, dright);
    :}
    |forr:f apar FOR_INIT:inicio E:cond puntoycoma E:aumeto cpar S:s1{:
        RESULT = new Forr(inicio, cond, aumeto, s1, fleft, fright);
    :}; 


FOR_INIT::= FIELD_DECLARATION:d {:      //CAMBIARLO POR LA DECLARCION NUEVA
            RESULT = d;
        :};


FIELD_MODIFIERS::= FIELD_MODIFIERS:j FIELD_MODIFIER:i{:
                        RESULT = j;
                        RESULT.add(i);
                   :}
                   |FIELD_MODIFIER:i{:
                        RESULT = new LinkedList<String>();
                        RESULT.add(i);
                   :};

FIELD_MODIFIER::= publico:d {: RESULT = d;:}
                 |protegido:d {: RESULT = d; :}
                 |privado:d {: RESULT = d; :}
                 |estatico:d {: RESULT = d; :}
                 |finall:d {: RESULT = d; :};


FIELD_DECLARATION::= FIELD_MODIFIERS:vi T:tipop VARIABLE_DECLARATORS:lista puntoycoma{:
                        RESULT = new Declaraciones(vi, tipop, lista, tipopleft, tipopright);
                    :}
                    |T:tipop VARIABLE_DECLARATORS:lista puntoycoma{:
                        RESULT = new Declaraciones(tipop, lista, tipopleft, tipopright);
                    :};

VARIABLE_DECLARATORS::= VARIABLE_DECLARATORS:d coma VARIABLE_DECLARATOR:i{:
                            RESULT = d;
                            RESULT.add(i);
                      :}
                      |VARIABLE_DECLARATOR:i{:
                            RESULT = new LinkedList<Object>();
                            RESULT.add(i);
                      :};

VARIABLE_DECLARATOR::= VARIABLE_DECLARATOR_ID:lista igual E:e {:
                            RESULT = new VariableDeclarator(lista, e, eleft, eright);
                      :}
                      |VARIABLE_DECLARATOR_ID:d{:
                            RESULT = d;
                      :};

VARIABLE_DECLARATOR_ID::= VARIABLE_DECLARATOR_ID:i acorchete ccorchete {:
                            RESULT = i;
                            RESULT.add(new Corchetee());                                
                        :}
                        |id:id{:
                            RESULT = new LinkedList<NodoAST>();
                            RESULT.add(new Identificador(id, idleft, idright));
                        :};



/*D::= T id acorchete ccorchete acorchete ccorchete igual E puntoycoma{:
        
    :}
    |T:t id:id igual E:e puntoycoma {:  //declaracion asignacion
        RESULT = new Declaracion(t,id, e, idleft, idright);
    :}
    |T:t id:id puntoycoma {:    //declaracion
        RESULT = new Declaracion(t, id, idleft, idright);
    :}
    |id:id igual E:e puntoycoma{: //asignacion
        RESULT = new Asignacion(id, e, idleft, idright);
    :};*/


PREPOSTFIJOS::= id:id masmas puntoycoma{:
                RESULT = new OPPostFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MAS, idleft, idright);
            :}%prec masmaspost
            |id:id menosmenos puntoycoma{:
                RESULT = new OPPostFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MENOS, idleft, idright);
            :}%prec menosmenospost
            |masmas id:id puntoycoma{:
                RESULT = new OPPreFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MAS, idleft, idright);
            :}%prec masmas
            |menosmenos id:id puntoycoma{:
                RESULT = new OPPreFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MENOS, idleft, idright);
            :}%prec menosmenos;


IMPRESIONES::= print apar E:e1 cpar puntoycoma{:
                RESULT = new Printer(e1, e1left, e1right);
            :}
            |printLinea apar E:e1 cpar puntoycoma{:
                RESULT = new Printer(e1, e1left, e1right, true);
            :}
            |imprimir apar cpar puntoycoma {:
                RESULT = new ImprimirTS("hola");
            :};


T::= intt{:
        //RESULT = Simbolo.Tipo.INT;
        RESULT = new TipoContenedor(Simbolo.Tipo.INT);
    :}
    |charr {:
        //RESULT = Simbolo.Tipo.CHAR;
        RESULT = new TipoContenedor(Simbolo.Tipo.CHAR);
    :}
    |stringg{:
        //RESULT = Simbolo.Tipo.STRING;
        RESULT = new TipoContenedor(Simbolo.Tipo.STRING);
    :}
    |booleann{:
        //RESULT = Simbolo.Tipo.BOOLEAN;
        RESULT = new TipoContenedor(Simbolo.Tipo.BOOLEAN);
    :}
    |doublee{:
        //RESULT = Simbolo.Tipo.DOUBLE;
        RESULT = new TipoContenedor(Simbolo.Tipo.DOUBLE);
    :};

E::= menos:mas E:e1 {:
        RESULT = new Aritmetica(e1, Operacion.Operador.NEGATIVO, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}%prec MENOSUNARIO    
    |mas:mas E:e1 {:
        RESULT = new Aritmetica(e1, Operacion.Operador.POSITIVO, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}%prec MASUNARIO
    |E:e1 oor:mas E:e2 {:
        RESULT = new Logica(e1, e2, Operacion.Operador.OR, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}    
    |E:e1 aand:mas E:e2 {:
        RESULT = new Logica(e1, e2, Operacion.Operador.AND, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}    
    |E:e1 igualigual:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.IGUAL, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 diferente:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.DIFERENTE, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |diferenteunario:mas E:e1 {:
        RESULT = new Logica(e1, Operacion.Operador.NOT, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}    
    |E:e1 mayorq:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.MAYORQ, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 menorq:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.MENORQ, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 mayorigualq:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.MAYORIGUALQ, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 menorigualq:mas E:e2 {:
        RESULT = new Relacional(e1, e2, Operacion.Operador.MENORIGUALQ, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 mas:mas E:e2{:
        RESULT = new Aritmetica(e1, e2, Operacion.Operador.MAS, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 por:mas E:e2{:
        RESULT = new Aritmetica(e1, e2, Operacion.Operador.POR, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 dividir:mas E:e2{:
        RESULT = new Aritmetica(e1, e2, Operacion.Operador.DIVIDIR, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    |E:e1 potencia:mas E:e2{:
        RESULT = new Aritmetica(e1, e2, Operacion.Operador.POTENCIA, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}        
    |E:e1 menos:mas E:e2{:
        RESULT = new Aritmetica(e1, e2, Operacion.Operador.MENOS, masleft, masright, new TipoContenedor(Simbolo.Tipo.STRING));
    :}
    
    |cadena:ee{:
        //ee.substring(1,ee.length()-1)
        RESULT = new Cadena(ee, new TipoContenedor(Simbolo.Tipo.STRING), eeleft, eeright);
    :}
    |entero:ee {:
        RESULT = new Entero(ee, new TipoContenedor(Simbolo.Tipo.INT), eeleft, eeright);
    :}
    |decimal:ee {:
        RESULT = new Decimal(ee, new TipoContenedor(Simbolo.Tipo.DOUBLE), eeleft, eeright);
    :}
    |charER: ee {:
        
        Object ww = ee.substring(1,ee.length()-1);
        RESULT = new Caracter(ww, new TipoContenedor(Simbolo.Tipo.CHAR), eeleft, eeright);
    :}
    |truee:ee{:
        RESULT = new Booleano(ee,new TipoContenedor(Simbolo.Tipo.BOOLEAN), eeleft, eeright);
    :}
    |falsee:ee{:
        RESULT = new Booleano(ee,new TipoContenedor(Simbolo.Tipo.BOOLEAN), eeleft, eeright);
    :}
    |id:id{:
        RESULT = new Identificador(id, new TipoContenedor(Simbolo.Tipo.ID), idleft, idright);
    :}
    
    |E:cond interrogacion E:vdd dospuntos E:fake {:
        RESULT = new OpTernario(cond, vdd, fake,condleft, condright);
    :}
    |id:id masmas {:
        RESULT = new OPPostFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MAS, idleft, idright);
    :}%prec masmaspost

    |id:id menosmenos {:
        RESULT = new OPPostFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MENOS, idleft, idright);
    :}%prec menosmenospost

    |masmas id:id {:
        RESULT = new OPPreFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MAS, idleft, idright);
    :}%prec masmas

    |menosmenos id:id {:
         RESULT = new OPPreFijo(new Identificador(id, null, idleft, idleft), Operacion.Operador.MENOS, idleft, idright);
    :}%prec menosmenos

    |read_file apar E:ruta  cpar {:
        RESULT = new LeerArchivo(ruta, rutaleft, rutaright);
    :}
    |write_file:a apar E:ruta coma E:contenido cpar {:
        RESULT = new EscribirArchivo(ruta, contenido, aleft, aright);
    :}
    
    |neww T PARACORCHETE {: //luego de t pone otro terminal para bajar una y meter las demas opciones del new

    :}


    |apar E:e cpar {:
        RESULT = e;
    :};


PARACORCHETE::= PARACORCHETE acorchete E ccorchete

              |acorchete E ccorchete {:
              
              :};
    

